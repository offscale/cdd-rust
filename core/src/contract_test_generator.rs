#![deny(missing_docs)]

//! # Contract Test Generator
//!
//! Generates integration tests that verify API implementation against the OpenAPI specification.
//!
//! The generated file:
//! - Defines a test function for each parsed route.
//! - Uses backend strategy (e.g. Actix) to send requests.
//! - Validates responses against the JSON schema defined in `openapi.yaml`.

use crate::error::AppResult;
use crate::oas::{ParamSource, ParsedRoute};
use crate::strategies::BackendStrategy;

/// Generates the content of `tests/api_contracts.rs`.
///
/// # Arguments
///
/// * `routes` - List of routes to test.
/// * `openapi_path` - Path to the `openapi.yaml` file (tested at runtime relative to crate root).
/// * `app_factory` - Path to the app initialization function (e.g., `crate::create_app`).
/// * `strategy` - The backend strategy (e.g. Actix) used to generate code.
///
/// # Returns
///
/// * `AppResult<String>` - Full content of the Rust test file.
pub fn generate_contract_tests_file(
    routes: &[ParsedRoute],
    openapi_path: &str,
    app_factory: &str,
    strategy: &impl BackendStrategy,
) -> AppResult<String> {
    let mut code = String::new();

    // 1. Headers and Imports
    code.push_str("//! Generated Integration Tests (Contract Checks)\n");
    code.push_str("//! \n");
    code.push_str("//! This file is auto-generated by cdd-rust. \n");
    code.push_str("//! It verifies that the implementation follows the OpenAPI contract.\n\n");
    code.push_str(&strategy.test_imports());

    // 2. Constants
    code.push_str(&format!(
        "const OPENAPI_PATH: &str = \"{}\";\n\n",
        openapi_path
    ));

    // 3. Generate Test Functions
    for route in routes {
        code.push_str(&generate_test_fn(route, app_factory, strategy));
        code.push('\n');
    }

    // 4. Generate Validation Helper
    code.push_str(&strategy.test_validation_helper());

    Ok(code)
}

fn generate_test_fn(
    route: &ParsedRoute,
    app_factory: &str,
    strategy: &impl BackendStrategy,
) -> String {
    let fn_name = format!("test_{}", route.handler_name);

    // Construct URI with dummy params
    // /users/{id} -> /users/00000000-0000-0000-0000-000000000000 (if uuid)
    let mut uri = route.path.clone();

    for param in &route.params {
        if param.source == ParamSource::Path {
            let placeholder = format!("{{{}}}", param.name);
            let dummy = get_dummy_value(&param.ty);
            uri = uri.replace(&placeholder, &dummy);
        }
    }

    // Add Query params ?param=val
    let query_params: Vec<String> = route
        .params
        .iter()
        .filter(|p| p.source == ParamSource::Query)
        .map(|p| format!("{}={}", p.name, get_dummy_value(&p.ty)))
        .collect();

    if !query_params.is_empty() {
        uri.push('?');
        uri.push_str(&query_params.join("&"));
    }

    // Body handling
    let body_setup = if route.request_body.is_some() {
        strategy.test_body_setup_code()
    } else {
        String::new()
    };

    let mut code = String::new();

    // Annotation & Signature
    code.push_str(&strategy.test_fn_signature(&fn_name));
    code.push('\n');

    // 1. Init App
    code.push_str("    // 1. Init App\n");
    code.push_str(&strategy.test_app_init(app_factory));
    code.push('\n');

    // 2. Create Request
    code.push_str("    // 2. Create Request\n");
    code.push_str(&strategy.test_request_builder(&route.method, &uri, &body_setup));
    code.push('\n');

    // 3. Call Service
    code.push_str("    // 3. Call Service\n");
    code.push_str(&strategy.test_api_call());
    code.push('\n');

    // 4. Assertions
    code.push_str("    // 4. Assertions\n");
    code.push_str(&strategy.test_assertion());
    code.push('\n');

    // 5. Schema Validation (Commented out placeholder usually)
    code.push_str("    // 5. Schema Validation\n");
    code.push_str(&format!(
        "    // validate_response(resp, \"{}\", \"{}\").await;\n",
        route.method.to_uppercase(),
        route.path
    ));

    code.push_str("}\n");
    code
}

fn get_dummy_value(ty: &str) -> String {
    if ty.contains("Uuid") {
        "00000000-0000-0000-0000-000000000000".to_string()
    } else if ty.contains("i32") || ty.contains("i64") || ty.contains("Integer") {
        "1".to_string()
    } else if ty.contains("bool") || ty.contains("Boolean") {
        "true".to_string()
    } else if ty.contains("Date") {
        "2023-01-01T00:00:00Z".to_string()
    } else {
        "test_val".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::oas::models::RouteKind;
    use crate::oas::{BodyFormat, ParamSource, ParsedRoute, RequestBodyDefinition};
    use crate::strategies::ActixStrategy;

    #[test]
    fn test_generate_contract_test_structure() {
        let routes = vec![ParsedRoute {
            path: "/users/{id}".into(),
            method: "GET".into(),
            handler_name: "get_user".into(),
            params: vec![crate::oas::RouteParam {
                name: "id".into(),
                source: ParamSource::Path,
                ty: "Uuid".into(),
            }],
            request_body: None,
            security: vec![],
            response_type: None,
            kind: RouteKind::Path,
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(
            &routes,
            "tests/openapi.yaml",
            "crate::create_app",
            &strategy,
        )
        .unwrap();

        assert!(code.contains("#[actix_web::test]"));
        assert!(code.contains("async fn test_get_user()"));
        // Check dummy replacement for UUID
        assert!(code.contains(".uri(\"/users/00000000-0000-0000-0000-000000000000\")"));
        // Check validation helper existence
        assert!(code.contains("async fn validate_response"));
        assert!(code.contains("const OPENAPI_PATH: &str = \"tests/openapi.yaml\";"));
        // Check factory call
        assert!(code.contains("crate::create_app(App::new())"));
    }

    #[test]
    fn test_generate_with_query_params() {
        let routes = vec![ParsedRoute {
            path: "/search".into(),
            method: "GET".into(),
            handler_name: "search_items".into(),
            params: vec![
                crate::oas::RouteParam {
                    name: "q".into(),
                    source: ParamSource::Query,
                    ty: "String".into(),
                },
                crate::oas::RouteParam {
                    name: "page".into(),
                    source: ParamSource::Query,
                    ty: "i32".into(),
                },
            ],
            request_body: None,
            security: vec![],
            response_type: None,
            kind: RouteKind::Path,
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        // Check query string construction
        assert!(code.contains("?q=test_val&page=1"));
    }

    #[test]
    fn test_generate_with_body() {
        let routes = vec![ParsedRoute {
            path: "/create".into(),
            method: "POST".into(),
            handler_name: "create_item".into(),
            params: vec![],
            request_body: Some(RequestBodyDefinition {
                ty: "Item".into(),
                format: BodyFormat::Json,
            }),
            security: vec![],
            response_type: None,
            kind: RouteKind::Path,
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        assert!(code.contains(".set_json(serde_json::json!"));
        assert!(code.contains("test::TestRequest::post()"));
    }

    #[test]
    fn test_dummy_values() {
        assert_eq!(get_dummy_value("i32"), "1");
        assert_eq!(get_dummy_value("bool"), "true");
        assert_eq!(get_dummy_value("Unknown"), "test_val");
        assert!(get_dummy_value("NaiveDateTime").contains("2023"));
    }
}
