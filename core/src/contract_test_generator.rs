#![deny(missing_docs)]

//! # Contract Test Generator
//!
//! Generates integration tests that verify API implementation against the OpenAPI specification.

use crate::error::AppResult;
use crate::oas::{ParamSource, ParsedRoute};
use crate::strategies::BackendStrategy;

/// Generates the content of `tests/api_contracts.rs`.
pub fn generate_contract_tests_file(
    routes: &[ParsedRoute],
    openapi_path: &str,
    app_factory: &str,
    strategy: &impl BackendStrategy,
) -> AppResult<String> {
    let mut code = String::new();

    code.push_str("//! Generated Integration Tests (Contract Checks)\n");
    code.push_str("//! \n");
    code.push_str("//! This file is auto-generated by cdd-rust. \n");
    code.push_str("//! It verifies that the implementation follows the OpenAPI contract.\n\n");
    code.push_str(&strategy.test_imports());

    code.push_str(&format!(
        "const OPENAPI_PATH: &str = \"{}\";\n\n",
        openapi_path
    ));

    for route in routes {
        code.push_str(&generate_test_fn(route, app_factory, strategy));
        code.push('\n');
    }

    code.push_str(&strategy.test_validation_helper());

    Ok(code)
}

fn generate_test_fn(
    route: &ParsedRoute,
    app_factory: &str,
    strategy: &impl BackendStrategy,
) -> String {
    let fn_name = format!("test_{}", route.handler_name);

    // Prepend base_path if it exists.
    // This allows tests to hit scopes like `/api/v1/users` even if the route definition is just `/users`.
    let full_path_template = if let Some(base) = &route.base_path {
        format!("{}{}", base, route.path)
    } else {
        route.path.clone()
    };

    let mut uri = full_path_template.clone();

    for param in &route.params {
        if param.source == ParamSource::Path {
            let placeholder = format!("{{{}}}", param.name);
            let dummy = get_dummy_value(&param.ty);
            uri = uri.replace(&placeholder, &dummy);
        }
    }

    if let Some(qs_param) = route
        .params
        .iter()
        .find(|p| p.source == ParamSource::QueryString)
    {
        let raw_query = build_querystring_value(qs_param);
        if !raw_query.is_empty() {
            uri.push('?');
            uri.push_str(&raw_query);
        }
    } else {
        let query_params: Vec<String> = route
            .params
            .iter()
            .filter(|p| p.source == ParamSource::Query)
            .map(|p| format!("{}={}", p.name, get_dummy_value(&p.ty)))
            .collect();

        if !query_params.is_empty() {
            uri.push('?');
            uri.push_str(&query_params.join("&"));
        }
    }

    let body_setup = if route.request_body.is_some() {
        strategy.test_body_setup_code()
    } else {
        String::new()
    };

    let mut code = String::new();

    code.push_str(&strategy.test_fn_signature(&fn_name));
    code.push('\n');

    code.push_str("    // 1. Init App\n");
    code.push_str(&strategy.test_app_init(app_factory));
    code.push('\n');

    code.push_str("    // 2. Create Request\n");
    code.push_str(&strategy.test_request_builder(&route.method, &uri, &body_setup));
    code.push('\n');

    code.push_str("    // 3. Call Service\n");
    code.push_str(&strategy.test_api_call());
    code.push('\n');

    code.push_str("    // 4. Assertions\n");
    code.push_str(&strategy.test_assertion());
    code.push('\n');

    code.push_str("    // 5. Schema Validation\n");
    code.push_str(&format!(
        "    validate_response(resp, \"{}\", \"{}\").await;\n",
        route.method.to_uppercase(),
        route.path
    ));

    code.push_str("}\n");
    code
}

fn get_dummy_value(ty: &str) -> String {
    if ty.contains("Uuid") {
        "00000000-0000-0000-0000-000000000000".to_string()
    } else if ty.contains("i32") || ty.contains("i64") || ty.contains("Integer") {
        "1".to_string()
    } else if ty.contains("bool") || ty.contains("Boolean") {
        "true".to_string()
    } else if ty.contains("Date") {
        "2023-01-01T00:00:00Z".to_string()
    } else {
        "test_val".to_string()
    }
}

fn build_querystring_value(param: &crate::oas::RouteParam) -> String {
    let value = get_dummy_value(&param.ty);
    format!("{}={}", param.name, value)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::oas::models::RouteKind;
    use crate::oas::{BodyFormat, ParamSource, ParsedRoute, RequestBodyDefinition};
    use crate::strategies::ActixStrategy;

    #[test]
    fn test_generate_contract_test_structure() {
        let routes = vec![ParsedRoute {
            path: "/users/{id}".into(),
            base_path: None,
            method: "GET".into(),
            handler_name: "get_user".into(),
            params: vec![crate::oas::RouteParam {
                name: "id".into(),
                source: ParamSource::Path,
                ty: "Uuid".into(),
                style: None,
                explode: false,
                allow_reserved: false,
            }],
            request_body: None,
            security: vec![],
            response_type: None,
            response_headers: vec![],
            response_links: None,
            kind: RouteKind::Path,
            tags: vec!["Users".into()],
            callbacks: vec![],
            deprecated: false,
            external_docs: None,
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(
            &routes,
            "tests/openapi.yaml",
            "crate::create_app",
            &strategy,
        )
        .unwrap();

        assert!(code.contains("#[actix_web::test]"));
        assert!(code.contains("async fn test_get_user()"));
        assert!(code.contains(".uri(\"/users/00000000-0000-0000-0000-000000000000\")"));
        assert!(code.contains("validate_response(resp, \"GET\", \"/users/{id}\").await;"));
    }

    #[test]
    fn test_generate_with_query_params() {
        let routes = vec![ParsedRoute {
            path: "/search".into(),
            base_path: None,
            method: "GET".into(),
            handler_name: "search_items".into(),
            params: vec![
                crate::oas::RouteParam {
                    name: "q".into(),
                    source: ParamSource::Query,
                    ty: "String".into(),
                    style: None,
                    explode: false,
                    allow_reserved: false,
                },
                crate::oas::RouteParam {
                    name: "page".into(),
                    source: ParamSource::Query,
                    ty: "i32".into(),
                    style: None,
                    explode: false,
                    allow_reserved: false,
                },
            ],
            request_body: None,
            security: vec![],
            response_type: None,
            response_headers: vec![],
            response_links: None,
            kind: RouteKind::Path,
            callbacks: vec![],
            deprecated: false,
            external_docs: None,
            tags: vec![],
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        assert!(code.contains("?q=test_val&page=1"));
    }

    #[test]
    fn test_generate_with_querystring_param() {
        let routes = vec![ParsedRoute {
            path: "/search".into(),
            base_path: None,
            method: "GET".into(),
            handler_name: "search_raw".into(),
            params: vec![crate::oas::RouteParam {
                name: "raw".into(),
                source: ParamSource::QueryString,
                ty: "String".into(),
                style: None,
                explode: false,
                allow_reserved: false,
            }],
            request_body: None,
            security: vec![],
            response_type: None,
            response_headers: vec![],
            response_links: None,
            kind: RouteKind::Path,
            callbacks: vec![],
            deprecated: false,
            external_docs: None,
            tags: vec![],
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        assert!(code.contains("?raw=test_val"));
    }

    #[test]
    fn test_generate_with_body() {
        let routes = vec![ParsedRoute {
            path: "/create".into(),
            base_path: None,
            method: "POST".into(),
            handler_name: "create_item".into(),
            params: vec![],
            request_body: Some(RequestBodyDefinition {
                ty: "Item".into(),
                format: BodyFormat::Json,
                encoding: None,
            }),
            security: vec![],
            response_type: None,
            response_headers: vec![],
            response_links: None,
            kind: RouteKind::Path,
            callbacks: vec![],
            deprecated: false,
            external_docs: None,
            tags: vec![],
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        assert!(code.contains(".set_json(serde_json::json!"));
    }

    #[test]
    fn test_generate_with_base_path() {
        let routes = vec![ParsedRoute {
            path: "/ping".into(),
            base_path: Some("/api/v1".into()),
            method: "GET".into(),
            handler_name: "ping".into(),
            params: vec![],
            request_body: None,
            security: vec![],
            response_type: None,
            response_headers: vec![],
            response_links: None,
            kind: RouteKind::Path,
            callbacks: vec![],
            deprecated: false,
            external_docs: None,
            tags: vec![],
        }];

        let strategy = ActixStrategy;
        let code = generate_contract_tests_file(&routes, "doc.yaml", "init", &strategy).unwrap();
        // Expect URI to include base path
        assert!(code.contains(".uri(\"/api/v1/ping\")"));
        // Expect validation logic to use original template
        assert!(code.contains("validate_response(resp, \"GET\", \"/ping\").await;"));
    }
}
